// Generated using `moon info`, DON'T EDIT IT
package "altsia/altsia/core"

import {
  "moonbitlang/core/debug",
  "moonbitlang/core/hashmap",
  "moonbitlang/core/list",
}

// Values
pub fn altsia_normalize_diagnostics(String, language? : String, max_width? : Int, weak_toplevel_constraint? : Bool) -> Result[String, Array[RenderError]]

pub fn altsia_normalize_raise(String, max_width? : Int) -> String raise

pub fn altsia_normalize_range_diagnostics(String, Int, Int, language? : String, max_width? : Int) -> Result[String, Array[RenderError]]

pub fn altsia_normalize_range_raise(String, Int, Int, max_width? : Int) -> String raise

pub fn altsia_normalize_range_result(String, Int, Int, language? : String, max_width? : Int) -> Result[String, Array[String]]

pub fn altsia_normalize_result(String, language? : String, max_width? : Int) -> Result[String, Array[String]]

pub fn char_display_width(Char) -> Int

pub let default_language : String

pub let default_max_width : Int

#alias(elaborate_string_literal)
pub fn elaborate_name(S) -> String raise

pub fn is_wide_east_asian(Char) -> Bool

pub fn[E : Show] join_list(@list.List[E], separator? : String) -> String

pub fn render_error(Error, String, String) -> RenderError

pub fn render_error_supported_languages() -> Array[String]

pub fn render_error_to_string(RenderError) -> String

pub fn source_loc_from_offsets(String, Int, Int) -> SourceLoc

pub fn string_display_width(String) -> Int

pub fn to_source(Array[S]) -> String

// Errors
pub(all) suberror Stage1Error {
  InvalidQuoteBlockStart(loc~ : SourceLoc)
  InvalidApplicationStart(loc~ : SourceLoc)
  UnexpectedEof(context~ : String, loc~ : SourceLoc)
  EmptyApplicationHead(loc~ : SourceLoc)
  UnclosedApplication(loc~ : SourceLoc)
  UnclosedQuoteBlock(loc~ : SourceLoc)
  UnclosedQuoteInline(loc~ : SourceLoc)
  QuoteBlockRequiresPrecedingApp(loc~ : SourceLoc)
  QuoteBlockMustFollowApp(loc~ : SourceLoc)
  UnexpectedTopLevelToken(token~ : String, loc~ : SourceLoc)
}
pub impl Eq for Stage1Error
pub impl Show for Stage1Error

pub(all) suberror Stage1NormalizeError {
  InvalidRange(start_offset~ : Int, end_offset~ : Int, source_length~ : Int, loc~ : SourceLoc)
}
pub impl Eq for Stage1NormalizeError
pub impl Show for Stage1NormalizeError

pub(all) suberror Stage2Error {
  FunctionNameMustBePlainText(found~ : S, loc~ : SourceLoc?)
  TemplateRequiresNameAndParamList(items~ : Array[S], loc~ : SourceLoc?)
  TemplateParamsMustBeList(found~ : S, loc~ : SourceLoc?)
  TemplateParamApplicationMissingHead(found~ : S, loc~ : SourceLoc?)
  InternalInvariantViolation(context~ : String, loc~ : SourceLoc?)
}
pub impl Eq for Stage2Error
pub impl Show for Stage2Error

pub(all) suberror Stage2EtaleError {
  TemplateArityMismatch(template_name~ : String, expected~ : Int, got~ : Int, args~ : Array[Term], loc~ : SourceLoc?)
  MissingNamedArgument(template_name~ : String, param_name~ : String, loc~ : SourceLoc?)
  DuplicateNamedArgument(template_name~ : String, param_name~ : String, loc~ : SourceLoc?)
  NestedTemplateDefinitionInSubstitution(term~ : Term, loc~ : SourceLoc?)
  UnexpectedTemplateDefinitionInExpand(term~ : Term, loc~ : SourceLoc?)
}
pub impl Eq for Stage2EtaleError
pub impl Show for Stage2EtaleError

pub(all) suberror Stage3Error {
  AttributeExpectsAtMostOneValue(values~ : Array[Term], loc~ : SourceLoc?)
  UnexpectedTemplateDefinition(term~ : Term, loc~ : SourceLoc?)
}
pub impl Eq for Stage3Error
pub impl Show for Stage3Error

// Types and methods
pub(all) enum AppGap {
  Tight
  Space
}
pub impl Eq for AppGap
pub impl Show for AppGap
pub impl @debug.Debug for AppGap

pub(all) enum BlockNode {
  Paragraph(Array[InlineNode])
  Container(Element[InlineNode])
}
pub impl Eq for BlockNode
pub impl Show for BlockNode
pub impl @debug.Debug for BlockNode

pub(all) enum ES {
  EText(String)
  EQuote(String)
  EQuoteInline(String)
  EApp(Array[ES])
}
pub impl Eq for ES
pub impl Show for ES

pub(all) struct Element[T] {
  name : String
  attrs : Map[String, String]
  children : Array[T]
}
pub impl[T : Eq] Eq for Element[T]
pub impl[T : Show] Show for Element[T]
pub impl[T : @debug.Debug] @debug.Debug for Element[T]

pub(all) enum Html {
  Text(String)
  Comment(String)
  Element(Element[Html])
}
pub fn Html::elaborate_block(BlockNode) -> Self
pub fn Html::elaborate_inline(InlineNode) -> Self
pub fn Html::elaborate_node(Piece) -> Self
pub fn Html::from(Array[Piece], f? : (Array[Self]) -> Array[Self]) -> Self
pub fn Html::to_string(Self) -> String
pub fn Html::visit_element(Self, (Element[Self]) -> Element[Self]) -> Self
pub fn Html::visit_text(Self, (String) -> String) -> Self
pub impl Show for Html

pub(all) enum InlineNode {
  Text(String)
  Span(Element[InlineNode])
}
pub impl Eq for InlineNode
pub impl Show for InlineNode
pub impl @debug.Debug for InlineNode

pub type MarkdownAbbrev
pub fn MarkdownAbbrev::desugar(Html) -> Html

pub(all) enum Mdx {
  Text(String)
  Comment(String)
  Group(Array[Mdx])
  Element(Element[Mdx])
}
pub fn Mdx::elaborate_block(BlockNode) -> Self
pub fn Mdx::elaborate_inline(InlineNode) -> Self
pub fn Mdx::elaborate_node(Piece) -> Self
pub fn Mdx::from(Array[Piece], f? : (Array[Self]) -> Array[Self]) -> Self
pub fn Mdx::to_string(Self) -> String
pub impl Show for Mdx

pub(all) struct NamedAppArg {
  name : String
  values : Array[Term]
  loc : SourceLoc
}
pub impl Eq for NamedAppArg
pub impl Show for NamedAppArg
pub impl @debug.Debug for NamedAppArg

pub(all) enum Piece {
  Inline(InlineNode)
  Block(BlockNode)
  Comment(String)
}
pub impl Eq for Piece
pub impl Show for Piece
pub impl @debug.Debug for Piece

pub(all) struct RenderError {
  code : String
  phase : String
  message : String
  loc : SourceLoc?
  source_excerpt : String?
}
pub impl Eq for RenderError
pub impl Show for RenderError
pub impl @debug.Debug for RenderError

pub(all) enum S {
  Text(String, SourceLoc)
  QuoteInline(String, SourceLoc)
  QuoteBlock(String, SourceLoc)
  App(Array[S], Array[AppGap], SourceLoc)
}
pub fn S::loc(Self) -> SourceLoc
pub fn S::to_es(Self) -> ES
pub impl Eq for S
pub impl Show for S
pub impl @debug.Debug for S

pub(all) struct SourceLoc {
  start_offset : Int
  end_offset : Int
  line : Int
  column : Int
}
pub impl Eq for SourceLoc
pub impl Show for SourceLoc
pub impl @debug.Debug for SourceLoc

pub(all) struct SplitAppArgs {
  named : Array[NamedAppArg]
  positional : Array[Term]
}
pub impl Eq for SplitAppArgs
pub impl Show for SplitAppArgs
pub impl @debug.Debug for SplitAppArgs

pub type Stage1
pub fn Stage1::normalize(String, max_width? : Int) -> String raise
pub fn Stage1::normalize_range(String, Int, Int, max_width? : Int) -> String raise
pub fn Stage1::parse(String, weak_toplevel_constraint? : Bool) -> Array[S] raise
pub fn Stage1::parse_semantics(String) -> Array[ES] raise

pub type Stage2
pub fn Stage2::elaborate_node(S) -> Term raise
pub fn Stage2::pass(Array[S]) -> Array[Term] raise

pub type Stage2Chisel
pub fn Stage2Chisel::split_app_args(Array[Term], strip_layout_gap_spaces? : Bool) -> SplitAppArgs

pub type Stage2Etale
pub fn Stage2Etale::expand_program(Array[Term]) -> Array[Term] raise

pub type Stage2Extern
pub fn Stage2Extern::rewrite_apps(Array[Term], (String, Array[Term], SourceLoc) -> Array[Term]) -> Array[Term]

pub type Stage3
pub fn Stage3::pass(Array[Term]) -> Array[Piece] raise

pub struct Template {
  params : Array[String]
  param_defaults : Array[(String, Array[Term])]
  body : Array[Term]
}

pub(all) enum Term {
  Text(String, SourceLoc)
  App(String, Array[Term], SourceLoc)
  TemplateDefinition(String, Array[String], Array[(String, Array[Term])], Array[Term], SourceLoc)
  Splice(Array[Term], SourceLoc)
  Comment(String, SourceLoc)
}
pub fn Term::loc(Self) -> SourceLoc
pub impl Eq for Term
pub impl Show for Term
pub impl @debug.Debug for Term

// Type aliases
pub type AppRewriter = (String, Array[Term], SourceLoc) -> Array[Term]

pub type Doc = Array[Piece]

pub type Env = @hashmap.HashMap[String, Template]

pub type Name = String

pub type ParamsEnv = @hashmap.HashMap[String, Array[Term]]

pub type Visitor[X] = (X) -> X

// Traits
pub trait ToSource {
  to_source(Self) -> String
}

